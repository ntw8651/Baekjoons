'''
일정을 잡아보자면, 오늘은 고민하고
내일은 해밀턴 회로를 푸는 알고리즘을 찾아보고,뭐...인접 방문 그런거
그 다음은 정답을 찾아보기로...


근데 회로인지 아닌지로는 최대개수가 되냐 안되냐만... 볼 수 있지 않나..
회로가 될 수 있도록 컷해주는 건가?

차수가 3이상...에서
임의의 꼭짓점의 차수가 n/2 이상이란 건 모든 꼭짓점이란...건가?

아 그렇네 어차피 다른 곳은 다 연결되어있을 테니
다른걸 한줄로 쭉 잇고서 n/2이상이란건 그 꼭지는 모든 선과 연결되어있단 거고
그럼 이 꼭지에서 마무리를 하면 되는구..나?

근데 이건 안되잖아.
일단은... 연결 정보를 만드는 부분만 짜볼
홀수...인데? 11아니 17 흡...음. 그냥 머리랑 꼬리가 같이있다는 전재로 두고 두칸을 먹어가면서 하면...?
지금보니까 저 blank 한줄로 사이를 가르면 굉장히...오묘하구나 어지럽
얘는 그럼 모든 걸 돌 수 있는 얘네.
얘네는 하나가 남고.
얘는 두개가 남...아닌데 안남는데...?아 그렇네...안남는
그냥 어디로든 두칸씩 확장시킬 수 있으면 되는 것 같은데?
그렇단 건 무조건 하나 남거나 안남거나 둘 중 하나란 건가?
진짜...무조건...인 것 같은데?

뭐야, 구글 저거는 꽉채우기가 안된다고?...잠깐만, 꽉채우기가 되면 게임이 안끝나도록
할 수 있겠구나 일부로 이렇게 한 건가? 아하...못하는구..? 왜 252점이지?
17 * 17은... 170 + 49 + 70 = 240 289점...인데?

홀수 홀수 = -1
짝수 홀수 = 0
짝수 짝수 = 0

'''

n, m = map(int, input().split())
if(n%2==1 and m%2==1):
    print(n*m-1)
else:
    print(n*m)


'''
#오키 연결은 잘 됐
n, m = map(int, input().split())

paths = [[] for i in range(n*m)]

for i in range(m):
    for j in range(n):

        #상단
        if(i!=0):
            paths[i*n+j].append((i-1)*n + j)
        #하단
        if(i!=m-1):
            paths[i*n+j].append((i+1)*n + j)
        #좌측
        if(j!=0):
            paths[i*n+j].append((i)*n + j - 1)
        #우측
        if(j!=n-1):
            paths[i*n+j].append((i)*n + j + 1)
            '''
